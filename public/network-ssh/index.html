<!DOCTYPE html>
<html lang="en">

<head>
    <title>Dich&#x27;s Blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://blog.dich.bid/style.css">
    <link rel="stylesheet" href="https://blog.dich.bid/color/blue.css">

        <link rel="stylesheet" href="https://blog.dich.bid/color/background_dark.css">
    
    <link rel="stylesheet" href="https://blog.dich.bid/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="Dich's Blog">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://blog.dich.bid/network-ssh/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="Dich's Blog">
    <meta property="twitter:domain" content="blog.dich.bid">
    <meta property="twitter:url" content="https://blog.dich.bid/network-ssh/">

                <link rel="alternate" type="application/atom+xml" title="Dich&#x27;s Blog Atom Feed" href="https://blog.dich.bid/atom.xml" />
    
    
        <link rel="icon" type="image/png" href=&#x2F;dich.webp />
    
    <!-- ✅ Added center alignment styles -->
    <style>
        .footer {
            text-align: center;
            padding: 1rem 0;
        }

        .footer__inner {
            display: flex;
            justify-content: center;
            flex-direction: column;
            align-items: center;
        }

        .copyright {
            text-align: center;
        }
    </style>
</head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://blog.dich.bid" style="text-decoration: none;">
                    <div class="logo">
                      
                            Dich&#x27;s Blog
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://blog.dich.bid">Blog</a></li>
            
                <li><a href="https://blog.dich.bid/archive">Archive</a></li>
            
                <li><a href="https://blog.dich.bid/weekly">Weekly</a></li>
            
                <li><a href="https://blog.dich.bid/tags">Tags</a></li>
            
                <li><a href="https://blog.dich.bid/search">Search</a></li>
            
                <li><a href="https://blog.dich.bid/links">Links</a></li>
            
                <li><a href="https://blog.dich.bid/atom.xml">Rss</a></li>
            
                <li><a href="https://blog.dich.bid/about">About me</a></li>
            
                <li><a href="https://github.com/Dichgrem" target="_blank" rel="noopener noreferrer">My github</a></li>
            
                <li><a href="https://github.com/getzola/zola" target="_blank" rel="noopener noreferrer">Zola frame</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://blog.dich.bid/network-ssh/">网络艺术:SSH使用指南</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-05-02
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://blog.dich.bid/tags/network/">#Network</a></span>
    

        <div class="post-content">
            <p>前言 SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。</p>
<span id="continue-reading"></span><h2 id="li-shi">历史</h2>
<p>1995年，芬兰赫尔辛基工业大学的研究员 Tatu Ylönen 设计了 <code>SSH 协议的第一个版本（现称为 SSH 1）</code>，同时写出了第一个实现（称为 SSH1）。</p>
<p>当时，他所在的大学网络一直发生密码嗅探攻击，他不得不为服务器设计一个更安全的登录方式。写完以后，他就把这个工具公开了，允许其他人免费使用。</p>
<p>SSH 可以替换 rlogin、TELNET、FTP 和 rsh 这些不安全的协议，所以大受欢迎，用户快速增长，1995年底已经发展到五十个国家的20,000个用户。SSH 1 协议也变成 IETF 的标准文档。</p>
<p>1995年12月，由于客服需求越来越大，<code>TatuYlönen就成立了一家公司SCS，专门销售和开发SSH</code>。这个软件的后续版本，逐渐从免费软件变成了专有的商业软件。</p>
<p>SSH 1 协议存在一些安全漏洞，所以<code>1996年又提出了 SSH 2 协议（或者称为 SSH 2.0）</code>。这个协议与1.0版不兼容，在1997年进行了标准化，1998年推出了软件实现 SSH2。但是，官方的 SSH2 软件是一个专有软件，不能免费使用，而且 SSH1的有些功能也没有提供。</p>
<p>1999年，OpenBSD 的开发人员决定写一个<code>SSH 2 协议的开源实现</code> ，这就是 OpenSSH 项目。该项目最初是基于 SSH 1.2.12 版本，那是当时 SSH1 最后一个开源版本。但是，OpenSSH 很快就完全摆脱了原始的官方代码，在许多开发者的参与下，按照自己的路线发展。OpenSSH 随 OpenBSD 2.6 版本一起提供，以后又移植到其他操作系统，成为最流行的 SSH 实现。目前，Linux 的所有发行版几乎都自带 OpenSSH。</p>
<h2 id="kai-shi">开始</h2>
<p>李华是一个大学生，现在他买了一台服务器，公网IPv4为114.514.114.514,李华打算连到上面看看：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>ssh -p 22 root@114.514.114.514
</span></code></pre>
<p>随后命令行弹出了密码输入，李华输入了初始密码114514,成功登录了进去；现在每次登录只要输入一行命令就可以，大功告成！</p>
<h2 id="an-quan">安全</h2>
<p>一段时间后，李华的linux知识提高了不少，他发现有不少IP在用随机密码不断尝试登录自己的服务器！这太危险了！</p>
<p>于是，李华查阅了资料，发现有一篇博客<a href="https://blog.dich.bid/about-server-set/">乱七八糟:服务器初始化与安全设置</a>，于是他将openssh-server的端口改成了2333,并开启了fail2ban，这下应该安全了！</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>### 更换SSH端口
</span><span>
</span><span>使用root账户或已经有sudo权限的用户登录到系统。
</span><span>
</span><span>打开SSH配置文件`sshd_config`，可以使用文本编辑器如nano或vi。以下是使用nano编辑器的示例：
</span><span>
</span><span>sudo vim /etc/ssh/sshd_config
</span><span>
</span><span>在配置文件中找到以下行：
</span><span>
</span><span>Port 22
</span><span>
</span><span>这是SSH默认的端口号，你可以将其更改为你想要的任何未被占用的端口号。例如，将端口更改为2333：
</span><span>
</span><span>Port 2333
</span><span>
</span><span>保存并关闭文本编辑器。重新启动SSH服务，以应用更改：
</span><span>
</span><span>sudo service ssh restart
</span><span>
</span><span>或者，如果你的系统使用systemd，可以使用以下命令：
</span><span>
</span><span>sudo systemctl restart ssh
</span><span>
</span><span>### 安装 Fail2ban
</span><span>
</span><span>sudo apt-get install fail2ban
</span><span>
</span><span>#### Debian 12 及以上的版本需要手动安装 rsyslog
</span><span>
</span><span>sudo apt-get install rsyslog
</span><span>
</span><span>####启动 Fail2ban 服务
</span><span>
</span><span>sudo systemctl start fail2ban
</span><span>
</span><span>#### 开机自启动
</span><span>
</span><span>sudo systemctl enable fail2ban
</span><span>
</span><span>#### 查看 Fail2ban 服务状态
</span><span>
</span><span>sudo systemctl status fail2ban
</span><span>
</span></code></pre>
<p>但是服务器依然在被爆破，李华又又研究了以下教程，决定将自己的服务器由密码登录改为密钥登录，这下没有牛马来爆破了！</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>#### 执行以下命令生成.pub后缀的公钥和无后缀的密钥：
</span><span>
</span><span>ssh-keygen
</span><span>
</span><span>注意不同密钥对名称不能相同；同时可以为这两个文件用密码加密；
</span><span>
</span><span>#### 随后将.pub后缀的公钥中的内容写入服务器的~/.ssh/authorized_keys中；
</span><span>
</span><span>#### 使用以下命令编译服务器的SSH配置：
</span><span>
</span><span>vim /etc/ssh/sshd_config
</span><span>
</span><span>将其中的该行改为PasswordAuthentication no，保存退出；随后使用
</span><span>
</span><span>sudo systemctl restart sshd
</span><span>
</span><span>重启SSH即可禁用密码登录；
</span><span>
</span><span>#### 将PermitRootLogin一栏改为PermitRootLogin prohibit-password**，即可实现仅root用户密钥登录；
</span><span>
</span><span>#### 使用以下命令查看输出，
</span><span>
</span><span>sudo cat /etc/ssh/sshd_config | grep -E &#39;PasswordAuthentication|PubkeyAuthentication&#39;
</span><span>
</span><span>如有PasswordAuthentication no → 禁用密码登录以及PubkeyAuthentication yes → 允许密钥登录则成功。
</span><span>
</span><span>&gt; 注意authorized_keys**的权限为600，如果不是则需要改正：chmod 600 ~/.ssh/authorized_keys
</span></code></pre>
<h2 id="guan-li">管理</h2>
<p>现在服务器安全了，但随着服务器数量的增加，李华很快发现一个新问题，如何管理这些个SSH连接呢？手动输入太慢了，每次都要复制粘贴也很麻烦，但是又不得不用，总不能回退到密码时代吧？况且数量多了，密码也记不住。</p>
<p>于是李华运用软件工程学的思想，想着，这种大众的需求应该有人解决过了吧？果然，李华很快在GitHub上找到了一个开源跨平台的SSH管理软件，<a href="https://github.com/electerm/electerm">electerm</a>!</p>
<p><img src="/images/electerm.png" alt="electerm" /></p>
<p>通过在electerm的书签中写入服务器的地址，登录用户和密钥，只要打开electerm并点击书签就可以连接了，太方便了！</p>
<h2 id="fan-pu">返璞</h2>
<p>随着技术阅历的增长，李华看electerm越来越不顺眼：用它管理SSH固然方便，但同时这就得在各个系统上安装一个Electron架构的软件，而且用electerm的shell并不好用,并且备份electerm的配置不能给其他软件使用。终于，在一次界面崩溃之后李华忍无可忍，决定更换新的方案！</p>
<p>通过研究，李华发现原来openssh有自带的管理方法，且非常便捷好用。</p>
<p>首先，李华在用户目录下创建了一个<code>.ssh</code>文件夹，linux中在<code>/home/username/.ssh</code>这里，windows下在<code>C:\Users\username\.ssh</code>这里。</p>
<p>随后，李华安装了openssh在系统上，linux中一般已经存在，windows上在<code>设置-系统-可选功能-添加功能</code>中选中OpenSSH Client和openssh-server开启即可.</p>
<p>随后，李华在.ssh文件夹下创建了一个文件，名为<code>config</code>，并在其中写入以下内容：</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>Host US
</span><span>    HostName 114.514.114.514
</span><span>    User root
</span><span>    IdentityFile ~/.ssh/US
</span><span>    IdentitiesOnly yes
</span></code></pre>
<p>随后李华在对应的位置<code>~/.ssh/US</code>创建了一个文件，李华将服务器的私钥放了进去,里面是以<code>-----BEGIN OPENSSH PRIVATE KEY-----</code>开头<code>-----END OPENSSH PRIVATE KEY-----</code>结尾的私钥。</p>
<p>现在，要登录<code>114.514.114.514</code>这台服务器，只需要使用<code>ssh US</code>命令就可以连上服务器了，不用再手动输入了！</p>
<h2 id="gui-zhen">归真</h2>
<p>在进一步了解SSH之后，李华很快又发现了新的问题，服务器的私钥放在本地是不安全的！尤其是Windows这种安装源松散，鱼龙混杂的系统上。究竟有没有更好的方法呢？在对keepassxc进行研究后，李华终于得出了一个几乎完美的方案！</p>
<ul>
<li>开启keepassxc的SSH代理集成</li>
<li>本地.ssh文件夹只保留公钥</li>
<li>私钥保存在keepassxc的一个组中</li>
</ul>
<p>这样一来，当你执行<code>ssh xxx</code>时，ssh 不是去读私钥文件，而是通过<code>SSH_AUTH_SOCK</code>环境变量找到 KeePassXC 的 agent。KeePassXC 会提示你解锁数据库/确认使用密钥。私钥不会离开 KeePassXC，只是 KeePassXC <code>用私钥做一次签名</code>，把结果返回给 ssh。这样，<code>硬盘上不需要保存私钥文件</code>，安全性更高，且<code>只需要备份.ssh文件夹和keepassxc的kbdx文件</code>即可.</p>
<p>那么该怎么做呢？</p>
<p>首先，将.ssh文件夹中的config进行修改,把私钥文件改为公钥文件，同时创建对应的<code>~/.ssh/US.pub</code>公钥文件，里面是以ssh-ed25519或者ssh-rsa开头的公钥.</p>
<pre style="background-color:#151515;color:#e8e8d3;"><code><span>Host US
</span><span>    HostName 114.514.114.514
</span><span>    User root
</span><span>    IdentityFile ~/.ssh/US.pub
</span><span>    IdentitiesOnly yes
</span></code></pre>
<p>随后在keepassxc的设置-ssh代理中开启<code>启用SSH代理集成</code>.（openssh）</p>
<p>接下来在keepassxc中左侧栏<code>新建一个文件夹</code>，名为SSH，里面<code>新建条目</code>，标题为US（和config中一致），然后在右侧<code>高级</code>中<code>新建</code>附件，文件名为US（和config中保持一致），文件内容为US的私钥.随后在左侧SSH代理中选中<code>在打开或解锁数据库的时候，向代理添加密钥</code>和<code>数据库锁定或关闭时，从SSH代理中删除密钥</code>这两个选项，并将下面的<code>私钥</code>选择<code>附件</code>，即为我们刚刚在高级中新建的US，可以看到对应的公钥也出现了，上一步没有公钥的可以在这里添加.按<code>确定</code>后关闭keepassxc并重新开启，这时候就可以使用<code>ssh US</code>命令登录了！</p>
<blockquote>
<p>注意每次登录前先开启keepassxc并解锁！</p>
</blockquote>
<hr />
<p><strong>Done.</strong></p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://blog.dich.bid/about-baci/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">乱七八糟:Baci实验笔记</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://blog.dich.bid/about-gpg/">
                            <span class="button__text">乱七八糟:GPG使用小记</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Dichgrem</span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep"> :: CC BY-SA 4.0 :: A friend comes from distant lands</span>
                        </a>
                    </span>
                </div>
            </div>
    </footer>
    
</div>
</body>
</html>

